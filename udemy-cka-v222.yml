kubectl config use-context
kubectl config --kubeconfig=/root/my-kube-config use-context research
kubectl config --kubeconfig=/root/my-kube-config current-context


openssl x509 -in apiserver.crt --text -noout
kubectl get pods --as dev-user


cat k.yml 
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: developer
rules:
- apiGroups:
  - ""
  resources:
  - pods
  verbs:
  - list
  - create 
  - delete
  
  

cat k1.yml 
---  
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: dev-user-binding
subjects:
- kind: User
  name: dev-user 
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role 
  name: developer
  apiGroup: rbac.authorization.k8s.io
  
  
 Role Creation
  
 Create a Role named "pod-reader" that allows users to perform get, watch and list on pods:
 kubectl create role pod-reader --verb=get --verb=list --verb=watch --resource=pods
 
 Create a Role named "pod-reader" with resourceNames specified:
 kubectl create role pod-reader --verb=get --resource=pods --resource-name=readablepod --resource-name=anotherpod
 
 Create a Role named "foo" with apiGroups specified:
 kubectl create role foo --verb=get,list,watch --resource=replicasets.apps
 
 Create a Role named "foo" with subresource permissions:
 kubectl create role foo --verb=get,list,watch --resource=pods,pods/status

 Create a Role named "my-component-lease-holder" with permissions to get/update a resource with a specific name:
 kubectl create role my-component-lease-holder --verb=get,list,watch,update --resource=lease --resource-name=my-component
 
 https://kubernetes.io/docs/reference/access-authn-authz/rbac/
 

RoleBinding

kubectl create rolebinding bob-admin-binding --clusterrole=admin --user=bob --namespace=acme

kubectl create rolebinding myapp-view-binding --clusterrole=view --serviceaccount=acme:myapp --namespace=acme

kubectl create rolebinding myappnamespace-myapp-view-binding --clusterrole=view --serviceaccount=myappnamespace:myapp --namespace=acme

ClusterRole
Create a ClusterRole named "pod-reader" that allows user to perform get, watch and list on pods:
kubectl create clusterrole pod-reader --verb=get,list,watch --resource=pods

kubectl create clusterrole node-admin --verb=get,watch,list,create,delete --resource=nodes
kubectl create clusterrolebinding node-admin-binding --clusterrole=node-admin --user=michelle

kubectl create clusterrole storage-admin --verb=get,watch,list,create,delete --resource=persistentvolumes,storageclasses


kubectl create clusterrolebinding michelle-storage-admin --clusterrole=storage-admin  --user=michelle



Create a ClusterRole named "pod-reader" with resourceNames specified:

kubectl create clusterrole pod-reader --verb=get --resource=pods --resource-name=readablepod --resource-name=anotherpod

Create a ClusterRole named "foo" with apiGroups specified:

kubectl create clusterrole foo --verb=get,list,watch --resource=replicasets.apps

Create a ClusterRole named "foo" with subresource permissions:

kubectl create clusterrole foo --verb=get,list,watch --resource=pods,pods/status

Create a ClusterRole named "foo" with nonResourceURL specified:
kubectl create clusterrole "foo" --verb=get --non-resource-url=/logs/*

Create a ClusterRole named "monitoring" with an aggregationRule specified:
kubectl create clusterrole monitoring --aggregation-rule="rbac.example.com/aggregate-to-monitoring=true"

kubectl create clusterrolebinding 

Across the entire cluster, grant the permissions in the "cluster-admin" ClusterRole to a user named "root":
kubectl create clusterrolebinding root-cluster-admin-binding --clusterrole=cluster-admin --user=root

Across the entire cluster, grant the permissions in the "system:node-proxier" ClusterRole to a user named "system:kube-proxy":
kubectl create clusterrolebinding kube-proxy-binding --clusterrole=system:node-proxier --user=system:kube-proxy

Across the entire cluster, grant the permissions in the "view" ClusterRole to a service account named "myapp" in the namespace "acme":
kubectl create clusterrolebinding myapp-view-binding --clusterrole=view --serviceaccount=acme:myapp


etcdctl snapshot save --endpoints= --cacert= --cert= --key=

ETCDCTL_API=3 etcdctl --endpoints=https://127.0.0.1:2379 \
--cacert=/etc/kubernetes/pki/etcd/ca.crt \
--cert=/etc/kubernetes/pki/etcd/server.crt \
--key=/etc/kubernetes/pki/etcd/server.key \
snapshot save /opt/snapshot-pre-boot.db



ETCDCTL_API=3 etcdctl  --data-dir /var/lib/etcd-bkp \
snapshot restore /opt/snapshot-pre-boot.db





kubectl -n ingress-space create service ingress 

kubectl create nodeport NAME [--tcp=port:targetPort] [--dry-run=server|client|none]

kubectl create service nodeport myservice --node-port=31000 --tcp=3000:80

kubectl -n ingress-space expose deployment ingress-controller --port=80 --target-port=80 --type=NodePort --selector=nginx-ingress

kubectl expose service nginx --port=443 --target-port=8443 --name=nginx-https

https://jamesdefabia.github.io/docs/user-guide/kubectl/kubectl_expose/

kubectl -n ingress-space expose deployment ingress-controller \
--name=ingress --port=80 --target-port=80 --type=NodePort \
--selector=name=nginx-ingress \
--overrides  '{ "apiVersion": "v1","spec":{"ports":[{"port": 80,"protocol":"TCP","targetPort": 80,"nodePort": 30080}]}}'

apiVersion: v1
kind: Service
metadata:
  name: ingress-controller
  namespace: ingress-space
spec:
  ports:
  - nodePort: 30080
    port: 80
    protocol: TCP
    targetPort: 80
  selector:
    name: nginx-ingress
  type: NodePort
status:
  loadBalancer: {}


 - port: 80
    targetPort: 80
    protocol: TCP
    nodePort: 30080
    name: http


