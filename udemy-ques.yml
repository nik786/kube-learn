
PRACTICE TEST COMMANDS AND ARGUMENTS


1. Create a pod with the ubuntu image to run a container to sleep for 5000 seconds. 
Modify the file ubuntu-sleeper-2.yaml.

Note: Only make the necessary changes. Do not modify the name.

Pod Name: ubuntu-sleeper-2
Command: sleep 5000


2.
Create a pod using the file named ubuntu-sleeper-3.yaml. There is something wrong with it. Try to fix it!

Note: Only make the necessary changes. Do not modify the name.

Pod Name: ubuntu-sleeper-3
Command: sleep 1200

3.

Inspect the file Dockerfile given at /root/webapp-color directory. What command is run at container startup?

ROM python:3.6-alpine

RUN pip install flask

COPY . /opt/

EXPOSE 8080

WORKDIR /opt

ENTRYPOINT ["python", "app.py"]

CMD ["--color", "red"]

4.
Inspect the two files under directory webapp-color-2. What command is run at container startup?

Assume the image was created from the Dockerfile in this folder.


5.
Inspect the two files under directory webapp-color-3. What command is run at container startup?

Assume the image was created from the Dockerfile in this folder.

6.

Create a pod with the given specifications. By default it displays a blue background. 
Set the given command line arguments to change it to green

Pod Name: webapp-green
Image: kodekloud/webapp-color
Command line arguments: --color=green



apiVersion: v1 
kind: Pod 
metadata:
  name: webapp-green
  labels:
      name: webapp-green 
spec:
  containers:
  - name: simple-webapp
    image: kodekloud/webapp-color
    args: ["--color", "green"]





PRACTICE TEST ENV VARIABLES
1.
Create a new ConfigMap for the webapp-color POD. Use the spec given below.
ConfigName Name: webapp-config-map
Data: APP_COLOR=darkblue


2.
Update the environment variable on the POD to use the newly created ConfigMap
Note: Delete and recreate the POD. Only make the necessary changes. Do not modify the name of the Pod.

Pod Name: webapp-color
EnvFrom: webapp-config-map

3.


PRACTICE TEST SECRETS
Create a new secret named db-secret with the data given below.
You may follow any one of the methods discussed in lecture to create the secret.

Secret Name: db-secret
Secret 1: DB_Host=sql01
Secret 2: DB_User=root
Secret 3: DB_Password=password123

4.
Configure webapp-pod to load environment variables from the newly created secret.

Delete and recreate the pod if required.

Pod name: webapp-pod
Image name: kodekloud/simple-webapp-mysql
Env From: Secret=db-secret



PRACTICE TEST â€“ MULTI CONTAINER PODS

1.
Create a multi-container pod with 2 containers.
Use the spec given below.
If the pod goes into the crashloopbackoff then add sleep 1000 in the lemon container.

Name: yellow
Container 1 Name: lemon
Container 1 Image: busybox
Container 2 Name: gold
Container 2 Image: redis


2.

- env:
    - name: discovery.type
      value: single-node



Edit the pod to add a sidecar container to send logs to Elastic Search. Mount the log volume to the sidecar container.



Only add a new container. Do not modify anything else. Use the spec provided below.


Name: app
Container Name: sidecar
Container Image: kodekloud/filebeat-configured
Volume Mount: log-volume
Mount Path: /var/log/event-simulator/
Existing Container Name: app
Existing Container Image: kodekloud/event-simulator



PRACTICE TEST ROLLING UPDATES AND ROLLBACKS

Deployment Rolling Strategy

1.

Let us try that. Upgrade the application by setting the image on the deployment to kodekloud/webapp-color:v2

Do not delete and re-create the deployment. Only set the new image name for the existing deployment.

Deployment Name: frontend
Deployment Image: kodekloud/webapp-color:v2

2.

Change the deployment strategy to Recreate

Delete and re-create the deployment if necessary. Only update the strategy type for the existing deployment.

Deployment Name: frontend
Deployment Image: kodekloud/webapp-color:v2
Strategy: Recreate

3.

Upgrade the application by setting the image on the deployment to kodekloud/webapp-color:v3
Do not delete and re-create the deployment. Only set the new image name for the existing deployment.

Deployment Name: frontend
Deployment Image: kodekloud/webapp-color:v3

4.
You are requested to change the URLs at which the applications are made available.
Make the video application available at /stream


Ingress: ingress-wear-watch
Path: /stream
Backend Service: video-service
Backend Service Port: 8080

5.


You are requested to add a new path to your ingress to make the food delivery application available to your customers.
Make the new application available at /eat.



Ingress: ingress-wear-watch
Path: /eat
Backend Service: food-service
Backend Service Port: 8080


6.

View the Payment application using the /pay URL in your browser.
Click on the Ingress tab above your terminal, if its not open already, and append /pay to the URL in the browser.


You are requested to make the new application available at /pay.
Identify and implement the best approach to making this application available
on the ingress controller and test to make sure its working. Look into annotations: rewrite-target as well.

Ingress Created
Path: /pay
Configure correct backend service
Configure correct backend port


7.

Create the ingress resource to make the applications available at /wear and /watch on the Ingress service.
Create the ingress in the app-space namespace.

Ingress Created
Path: /wear
Path: /watch
Configure correct backend service for /wear
Configure correct backend service for /watch
Configure correct backend port for /wear service
Configure correct backend port for /watch service


8.

Let us now create a service to make Ingress available to external users.
Create a service following the given specs.


Name: ingress
Type: NodePort
Port: 80
TargetPort: 80
NodePort: 30080
Namespace: ingress-space
Use the right selector


PRACTICE TEST VIEW CERTIFICATE DETAILS

1.
Identify the Certificate file used to authenticate kube-apiserver as a client to ETCD Server

Run the command cat /etc/kubernetes/manifests/kube-apiserver.yaml and look for value of etcd-certfile flag.

2.
Identify the key used to authenticate kubeapi-server to the kubelet server
Look for kubelet-client-key option in the file /etc/kubernetes/manifests/kube-apiserver.yaml

3.
What is the Common Name (CN) configured on the Kube API Server Certificate?
openssl x509 -in file-path.crt -text -noout

4.
What is the name of the CA who issued the Kube API Server Certificate?
Run the command openssl x509 -in /etc/kubernetes/pki/apiserver.crt -text and look for issuer

5.
Which of the below alternate names is not configured on the Kube API Server Certificate?

Run the command openssl x509 -in /etc/kubernetes/pki/apiserver.crt -text and look at Alternative Names


6.
What is the Common Name (CN) configured on the ETCD Server certificate?
Run the command openssl x509 -in /etc/kubernetes/pki/etcd/server.crt -text and look for Subject CN.


7.
How long, from the issued date, is the Kube-API Server Certificate valid for?
Run the command openssl x509 -in /etc/kubernetes/pki/apiserver.crt -text and check on the Expiry date.

8.
How long, from the issued date, is the Root CA Certificate valid for?
File: /etc/kubernetes/pki/ca.crt

openssl x509 -in /etc/kubernetes/pki/ca.crt -text

9.
Kubectl suddenly stops responding to your commands. Check it out! 
Someone recently modified the /etc/kubernetes/manifests/etcd.yaml file
You are asked to investigate and fix the issue. Once you fix the issue 
wait for sometime for kubectl to respond. Check the logs of the ETCD container.

The certificate file used here is incorrect. It is set to /etc/kubernetes/pki/etcd/server-certificate.crt 
which does not exist. As we saw in the previous 
questions the correct path should be /etc/kubernetes/pki/etcd/server.crt.

Update the YAML file with the correct certificate path and wait for 
the ETCD pod to be recreated. wait for the kube-apiserver to get to a Ready state

KUBECONFIG TEST

1.
What is the current context set to in the my-kube-config file?
kubectl config current-context --kubeconfig my-kube-config

2.
I would like to use the dev-user to access test-cluster-1. 
Set the current context to the right one so I can do that.
Once the right context is identified, use the kubectl config use-context command.

To use that context, run the command: kubectl config --kubeconfig=/root/my-kube-config use-context research
To know the current context, run the command: kubectl config --kubeconfig=/root/my-kube-config current-context

3.
We don't want to have to specify the kubeconfig file option on each command. 
Make the my-kube-config file the default kubeconfig.

Replace the contents in the default kubeconfig file with the content from my-kube-config file.



3.

PRACTICE TEST ROLE BASED ACCESS CONTROLS

Inspect the environment and identify the authorization modes configured on the cluster.

kubectl describe pod kube-apiserver-controlplane -n kube-system and look for --authorization-mode.

4.
What actions can the kube-proxy role perform on configmaps?
Run the command: kubectl describe role -n kube-system kube-proxy and check under the Verbs column.

5.

A user dev-user is created. User's details have been added to the kubeconfig file. 
Inspect the permissions granted to the user. Check if the user can list pods in the default namespace.
Use the --as dev-user option with kubectl to run commands as the dev-user.

Run the command: kubectl get pods --as dev-user

6.

Create the necessary roles and role bindings required for the dev-user to create, list and 
delete pods in the default namespace.
Use the given spec:

Role: developer
Role Resources: pods
Role Actions: list
Role Actions: create
Role Actions: delete
RoleBinding: dev-user-binding
RoleBinding: Bound to dev-user

7.

The dev-user is trying to get details about the dark-blue-app pod in the blue namespace. 
Investigate and fix the issue.
We have created the required roles and rolebindings, but something seems to be wrong.

Run the command: kubectl edit role developer -n blue and correct the resourceNames field. 
You don't have to delete the role.

8.
Grant the dev-user permissions to create deployments in the blue namespace.
Remember to add for api group "apps"

---
kind: Role
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  namespace: blue
  name: dev-user-role
rules:
- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["create"]

---
kind: RoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: dev-user-role-binding
  namespace: blue
subjects:
- kind: User
  name: dev-user
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role
  name: dev-user-role
  apiGroup: rbac.authorization.k8s.io


Test Service Account


SECURITY CONTEXTS

What is the user used to execute the sleep process within the ubuntu-sleeper pod?
In the current(default) namespace.

kubectl exec ubuntu-sleeper -- whoami

2.
Edit the pod ubuntu-sleeper to run the sleep process with user ID 1010.
Note: Only make the necessary changes. Do not modify the name or image of the pod.

3.
A Pod definition file named multi-pod.yaml is given. With what user are the processes in the web container started?
The pod is created with multiple containers and security contexts defined at the Pod and Container level.

The User ID defined in the securityContext of the container overrides the User ID in the POD.

4.


5.

Update pod ubuntu-sleeper to run as Root user and with the SYS_TIME capability.
Note: Only make the necessary changes. Do not modify the name of the pod.

apiVersion: v1
kind: Pod
metadata:
  name: ubuntu-sleeper
  namespace: default
spec:
  containers:
  - command:
    - sleep
    - "4800"
    image: ubuntu
    name: ubuntu-sleeper
    securityContext:
      capabilities:
        add: ["SYS_TIME"]
        
 6.
 Now update the pod to also make use of the NET_ADMIN capability.
 Note: Only make the necessary changes. Do not modify the name of the pod.


Pod Name: ubuntu-sleeper
Image Name: ubuntu
SecurityContext: Capability SYS_TIME
SecurityContext: Capability NET_ADMIN

metadata:
  name: ubuntu-sleeper
  namespace: default
spec:
  containers:
  - command:
    - sleep
    - "4800"
    image: ubuntu
    name: ubuntu-sleeper
    securityContext:
      capabilities:
        add: ["SYS_TIME", "NET_ADMIN"]
        





1.

We decided to use a modified version of the application from an internal private registry. 
Update the image of the deployment to use a new image from myprivateregistry.com:5000
The registry is located at myprivateregistry.com:5000. 
Don't worry about the credentials for now. We will configure them in the upcoming steps.


2.
Create a secret object with the credentials required to access the registry.
Name: private-reg-cred
Username: dock_user
Password: dock_password
Server: myprivateregistry.com:5000
Email: dock_user@myprivateregistry.com

3.

Configure the deployment to use credentials from the new secret to pull images from the private registry

Edit deployment using kubectl edit deploy web command and add imagePullSecrets section. Use private-reg-cred.

4.






1.

Create a CertificateSigningRequest object with the name akshay with the contents of the akshay.csr file

---
apiVersion: certificates.k8s.io/v1
kind: CertificateSigningRequest
metadata:
  name: akshay
spec:
  groups:
  - system:authenticated
  request: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURSBSRVFVRVNULS0tLS0KTUlJQ1Zq
  Q0NBVDRDQVFBd0VURVBNQTBHQTFVRUF3d0dZV3R6YUdGNU1JSUJJakFOQmdrcWhraUc5dzBCQVFFR
  gpBQU9DQVE4QU1JSUJDZ0tDQVFFQXY4azZTTE9HVzcrV3JwUUhITnI2TGFROTJhVmQ1blNLaj
  R6UEhsNUlJYVdlCmJ4RU9JYkNmRkhKKzlIOE1RaS9hbCswcEkwR2xpYnlmTXozL2lGSWF3eGVXNFA3b
  DJjK1g0L0lqOXZQVC9jU3UKMDAya2ZvV0xUUkpQbWtKaVVuQTRpSGxZNDdmYkpQZDhIRGFuWHM3bnFoen
  VvTnZLbWhwL2twZUVvaHd5MFRVMAo5bzdvcjJWb1hWZTVyUnNoMms4dzV2TlVPL3BBdEk4VkRydUhCYzRxaHM3MDI1ZTZTUXFDeHUyOHNhTDh1blJQCkR6V2ZsNVpLcTVpdlJNeFQrcUo0UGpBL2pHV2d6QVliL1hDQXRrRVJyNlMwak9XaEw1Q0ErVU1BQmd5a1c5emQKTmlXbnJZUEdqVWh1WjZBeWJ1VzMxMjRqdlFvbndRRUprNEdoayt2SU53SURBUUFCb0FBd0RRWUpLb1pJaHZjTgpBUUVMQlFBRGdnRUJBQi94dDZ2d2EweWZHZFpKZ1k2ZDRUZEFtN2ZiTHRqUE15OHByTi9WZEdxN25oVDNUUE5zCjEwRFFaVGN6T21hTjVTZmpTaVAvaDRZQzQ0QjhFMll5Szg4Z2lDaUVEWDNlaDFYZnB3bnlJMVBDVE1mYys3cWUKMkJZTGJWSitRY040MDU4YituK24wMy9oVkN4L1VRRFhvc2w4Z2hOaHhGck9zRUtuVExiWHRsK29jQ0RtN3I3UwpUYTFkbWtFWCtWUnFJYXFGSDd1dDJveHgxcHdCdnJEeGUvV2cybXNqdHJZUXJ3eDJmQnErQ2Z1dm1sVS9rME4rCml3MEFjbVJsMy9veTdqR3ptMXdqdTJvNG4zSDNKQ25SbE41SnIyQkZTcFVQU3dCL1lUZ1ZobHVMNmwwRERxS3MKNTdYcEYxcjZWdmJmbTRldkhDNnJCSnNiZmI2ZU1KejZPMUU9Ci0tLS0tRU5EIENFUlRJRklDQVRFIFJFUVVFU1QtLS0tLQo=
  signerName: kubernetes.io/kube-apiserver-client
  usages:
  - client auth




3.

What is the Condition of the newly created Certificate Signing Request object?

kubectl get csr


4.
Approve the CSR Request
kubectl certificate approve akshay


5.

How many CSR requests are available on the cluster?


6.

During a routine check you realized that there is a new CSR request in place. What is the name of this request?


7.
You are not aware of a request coming in. What groups is this CSR requesting access to?
Check the details about the request. Preferebly in YAML.

8.



NetWork Policy

Create a network policy to allow traffic from the Internal application only to the payroll-service and db-service.
Use the spec given on the below. You might want to enable ingress traffic to the pod to test your rules in the UI.

Policy Name: internal-policy
Policy Type: Egress
Egress Allow: payroll
Payroll Port: 8080
Egress Allow: mysql
MySQL Port: 3306















