
PRACTICE TEST COMMANDS AND ARGUMENTS


1. Create a pod with the ubuntu image to run a container to sleep for 5000 seconds. 
Modify the file ubuntu-sleeper-2.yaml.

Note: Only make the necessary changes. Do not modify the name.

Pod Name: ubuntu-sleeper-2
Command: sleep 5000


2.
Create a pod using the file named ubuntu-sleeper-3.yaml. There is something wrong with it. Try to fix it!

Note: Only make the necessary changes. Do not modify the name.

Pod Name: ubuntu-sleeper-3
Command: sleep 1200

3.

Inspect the file Dockerfile given at /root/webapp-color directory. What command is run at container startup?

ROM python:3.6-alpine

RUN pip install flask

COPY . /opt/

EXPOSE 8080

WORKDIR /opt

ENTRYPOINT ["python", "app.py"]

CMD ["--color", "red"]

4.
Inspect the two files under directory webapp-color-2. What command is run at container startup?

Assume the image was created from the Dockerfile in this folder.


5.
Inspect the two files under directory webapp-color-3. What command is run at container startup?

Assume the image was created from the Dockerfile in this folder.

6.

Create a pod with the given specifications. By default it displays a blue background. 
Set the given command line arguments to change it to green

Pod Name: webapp-green
Image: kodekloud/webapp-color
Command line arguments: --color=green



apiVersion: v1 
kind: Pod 
metadata:
  name: webapp-green
  labels:
      name: webapp-green 
spec:
  containers:
  - name: simple-webapp
    image: kodekloud/webapp-color
    args: ["--color", "green"]





PRACTICE TEST ENV VARIABLES
1.
Create a new ConfigMap for the webapp-color POD. Use the spec given below.
ConfigName Name: webapp-config-map
Data: APP_COLOR=darkblue


2.
Update the environment variable on the POD to use the newly created ConfigMap
Note: Delete and recreate the POD. Only make the necessary changes. Do not modify the name of the Pod.

Pod Name: webapp-color
EnvFrom: webapp-config-map

3.


PRACTICE TEST SECRETS
Create a new secret named db-secret with the data given below.
You may follow any one of the methods discussed in lecture to create the secret.

Secret Name: db-secret
Secret 1: DB_Host=sql01
Secret 2: DB_User=root
Secret 3: DB_Password=password123

4.
Configure webapp-pod to load environment variables from the newly created secret.

Delete and recreate the pod if required.

Pod name: webapp-pod
Image name: kodekloud/simple-webapp-mysql
Env From: Secret=db-secret



PRACTICE TEST â€“ MULTI CONTAINER PODS

1.
Create a multi-container pod with 2 containers.
Use the spec given below.
If the pod goes into the crashloopbackoff then add sleep 1000 in the lemon container.

Name: yellow
Container 1 Name: lemon
Container 1 Image: busybox
Container 2 Name: gold
Container 2 Image: redis


2.

- env:
    - name: discovery.type
      value: single-node



Edit the pod to add a sidecar container to send logs to Elastic Search. Mount the log volume to the sidecar container.



Only add a new container. Do not modify anything else. Use the spec provided below.


Name: app
Container Name: sidecar
Container Image: kodekloud/filebeat-configured
Volume Mount: log-volume
Mount Path: /var/log/event-simulator/
Existing Container Name: app
Existing Container Image: kodekloud/event-simulator



PRACTICE TEST ROLLING UPDATES AND ROLLBACKS

Deployment Rolling Strategy

1.

Let us try that. Upgrade the application by setting the image on the deployment to kodekloud/webapp-color:v2

Do not delete and re-create the deployment. Only set the new image name for the existing deployment.

Deployment Name: frontend
Deployment Image: kodekloud/webapp-color:v2

2.

Change the deployment strategy to Recreate

Delete and re-create the deployment if necessary. Only update the strategy type for the existing deployment.

Deployment Name: frontend
Deployment Image: kodekloud/webapp-color:v2
Strategy: Recreate

3.

Upgrade the application by setting the image on the deployment to kodekloud/webapp-color:v3
Do not delete and re-create the deployment. Only set the new image name for the existing deployment.

Deployment Name: frontend
Deployment Image: kodekloud/webapp-color:v3

4.
You are requested to change the URLs at which the applications are made available.
Make the video application available at /stream


Ingress: ingress-wear-watch
Path: /stream
Backend Service: video-service
Backend Service Port: 8080

5.


You are requested to add a new path to your ingress to make the food delivery application available to your customers.
Make the new application available at /eat.



Ingress: ingress-wear-watch
Path: /eat
Backend Service: food-service
Backend Service Port: 8080


6.

View the Payment application using the /pay URL in your browser.
Click on the Ingress tab above your terminal, if its not open already, and append /pay to the URL in the browser.


You are requested to make the new application available at /pay.
Identify and implement the best approach to making this application available
on the ingress controller and test to make sure its working. Look into annotations: rewrite-target as well.

Ingress Created
Path: /pay
Configure correct backend service
Configure correct backend port


7.

Create the ingress resource to make the applications available at /wear and /watch on the Ingress service.
Create the ingress in the app-space namespace.

Ingress Created
Path: /wear
Path: /watch
Configure correct backend service for /wear
Configure correct backend service for /watch
Configure correct backend port for /wear service
Configure correct backend port for /watch service


8.

Let us now create a service to make Ingress available to external users.
Create a service following the given specs.


Name: ingress
Type: NodePort
Port: 80
TargetPort: 80
NodePort: 30080
Namespace: ingress-space
Use the right selector


PRACTICE TEST VIEW CERTIFICATE DETAILS

1.
Identify the Certificate file used to authenticate kube-apiserver as a client to ETCD Server

Run the command cat /etc/kubernetes/manifests/kube-apiserver.yaml and look for value of etcd-certfile flag.

2.
Identify the key used to authenticate kubeapi-server to the kubelet server
Look for kubelet-client-key option in the file /etc/kubernetes/manifests/kube-apiserver.yaml

3.
What is the Common Name (CN) configured on the Kube API Server Certificate?
openssl x509 -in file-path.crt -text -noout

4.
What is the name of the CA who issued the Kube API Server Certificate?
Run the command openssl x509 -in /etc/kubernetes/pki/apiserver.crt -text and look for issuer

5.
Which of the below alternate names is not configured on the Kube API Server Certificate?

Run the command openssl x509 -in /etc/kubernetes/pki/apiserver.crt -text and look at Alternative Names


6.
What is the Common Name (CN) configured on the ETCD Server certificate?
Run the command openssl x509 -in /etc/kubernetes/pki/etcd/server.crt -text and look for Subject CN.


7.
How long, from the issued date, is the Kube-API Server Certificate valid for?
Run the command openssl x509 -in /etc/kubernetes/pki/apiserver.crt -text and check on the Expiry date.

8.
How long, from the issued date, is the Root CA Certificate valid for?
File: /etc/kubernetes/pki/ca.crt

openssl x509 -in /etc/kubernetes/pki/ca.crt -text

9.
Kubectl suddenly stops responding to your commands. Check it out! 
Someone recently modified the /etc/kubernetes/manifests/etcd.yaml file
You are asked to investigate and fix the issue. Once you fix the issue 
wait for sometime for kubectl to respond. Check the logs of the ETCD container.

The certificate file used here is incorrect. It is set to /etc/kubernetes/pki/etcd/server-certificate.crt 
which does not exist. As we saw in the previous 
questions the correct path should be /etc/kubernetes/pki/etcd/server.crt.

Update the YAML file with the correct certificate path and wait for 
the ETCD pod to be recreated. wait for the kube-apiserver to get to a Ready state

KUBECONFIG TEST

1.
What is the current context set to in the my-kube-config file?
kubectl config current-context --kubeconfig my-kube-config

2.
I would like to use the dev-user to access test-cluster-1. 
Set the current context to the right one so I can do that.
Once the right context is identified, use the kubectl config use-context command.

To use that context, run the command: kubectl config --kubeconfig=/root/my-kube-config use-context research
To know the current context, run the command: kubectl config --kubeconfig=/root/my-kube-config current-context

3.
We don't want to have to specify the kubeconfig file option on each command. 
Make the my-kube-config file the default kubeconfig.

Replace the contents in the default kubeconfig file with the content from my-kube-config file.



3.









