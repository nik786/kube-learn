Day-2 operation in a hashtag#Kubernetes deployment requires managing the performance of the containerized applications. 
By correctly defining resource requests and limits, one can ensure that the pods receive the appropriate level 
of resource allocation and prioritize critical workloads
hashtag#k8s provides QoS classes to help prioritize and allocate resources effectively
that are classified under 3 buckets :
âœ… ğ†ğ®ğšğ«ğšğ§ğ­ğğğ - Pods with guaranteed QoS are allocated the highest priority. They are assured a certain amount of 
CPU and memory resources, ensuring that they receive the resources they request.
âœ… ğğ®ğ«ğ¬ğ­ğšğ›ğ¥ğ ğğ¨ğ’ - Pods with burstable QoS are given a certain amount of CPU and memory resources, but they are also allowed
to consume additional resources when available. However, these pods don't have strict resource guarantees, so they might
experience performance fluctuations during times of contention
âœ… ğğğ¬ğ­ ğ„ğŸğŸğ¨ğ«ğ­ ğğ¨ğ’ - Pods with best-effort QoS have the lowest priority. They receive resources only when there are spare 
resources available after serving higher-priority pods

So, when to choose the right QoS class for your application ğŸ¤” 
ğŸ‘‰ ğ‘®ğ’–ğ’‚ğ’“ğ’‚ğ’ğ’•ğ’†ğ’†ğ’… ğ‘¸ğ’ğ‘º: Pods with guaranteed QoS are ideal for applications with strict performance requirements. These pods 
have dedicated resources and are not impacted by resource contention from other pods.
ğŸ‘‰ ğ‘©ğ’–ğ’“ğ’”ğ’•ğ’‚ğ’ƒğ’ğ’† ğ’‘ğ’ğ’…ğ’”: are suitable for applications with varying resource demands. While they can consume additional 
resources when available, they might experience performance degradation during periods of high demand if not properly managed.
ğŸ‘‰ ğ‘©ğ’†ğ’”ğ’• ğ‘¬ğ’‡ğ’‡ğ’ğ’“ğ’• ğ‘¸ğ’ğ‘º: They are the first to be evicted if the cluster faces resource constraints. These are appropriate 
for non-critical tasks that can tolerate interruptions or occasional slowdowns


ğ“ğ¨ğ© 6 ğ¬ğ­ğ«ğšğ­ğğ ğ¢ğğ¬ ğŸğ¨ğ« ğ¬ğğœğ®ğ«ğ¢ğ§ğ  ğšğ§ğ² ğœğ¨ğ§ğŸğ¨ğ«ğ¦ğšğ§ğ­ ğŠğ®ğ›ğğ«ğ§ğğ­ğğ¬ ğœğ¥ğ®ğ¬ğ­ğğ« â˜¸ ğŸ›¡ 

ğŸ“Œ ğ‘¨ğ’–ğ’•ğ’‰ğ’†ğ’ğ’•ğ’Šğ’„ğ’‚ğ’•ğ’Šğ’ğ’ & ğ‘¨ğ’–ğ’•ğ’‰ğ’ğ’“ğ’Šğ’›ğ’‚ğ’•ğ’Šğ’ğ’
âœ… ğ˜´ğ˜ºğ˜´ğ˜µğ˜¦ğ˜®:ğ˜®ğ˜¢ğ˜´ğ˜µğ˜¦ğ˜³ğ˜´ group is not used for user or component authentication after bootstrapping.
âœ… The kube-controller-manager is running with --ğ˜¶ğ˜´ğ˜¦-ğ˜´ğ˜¦ğ˜³ğ˜·ğ˜ªğ˜¤ğ˜¦-ğ˜¢ğ˜¤ğ˜¤ğ˜°ğ˜¶ğ˜¯ğ˜µ-ğ˜¤ğ˜³ğ˜¦ğ˜¥ğ˜¦ğ˜¯ğ˜µğ˜ªğ˜¢ğ˜­ğ˜´ enabled.
âœ… The root certificate is protected (either an offline CA, or a managed online CA with effective access controls).
âœ… Intermediate and leaf certificates have an expiry date no more than 3 years in the future.
âœ… Running all of kube-controller-manager as ğ˜´ğ˜ºğ˜´ğ˜µğ˜¦ğ˜®:ğ˜®ğ˜¢ğ˜´ğ˜µğ˜¦ğ˜³ğ˜´ should be avoided.

ğŸ“Œ ğ‘µğ’†ğ’•ğ’˜ğ’ğ’“ğ’Œ ğ’”ğ’†ğ’„ğ’–ğ’“ğ’Šğ’•ğ’š
âœ… Ingress and egress network policies are applied to all workloads in the cluster.
âœ… Default network policies within each namespace, selecting all pods, denying everything, are in place.
âœ… If appropriate, a service mesh is used to encrypt all communications inside of the cluster.
âœ… The Kubernetes API, kubelet API and etcd are not exposed publicly on Internet.
âœ… Access from the workloads to the cloud metadata API is filtered.
âœ… Use of LoadBalancer and ExternalIPs is restricted

ğŸ“Œ ğ‘·ğ’ğ’… ğ‘ºğ’†ğ’„ğ’–ğ’“ğ’Šğ’•ğ’š
âœ… RBAC rights to create, update, patch, delete workloads is only granted if necessary.
âœ… Appropriate Pod Security Standards policy is applied for all namespaces and enforced.
âœ… Memory limit is set for the workloads with a limit equal or inferior to the request.
âœ… CPU limit might be set on sensitive workloads.
âœ… Seccomp is enabled with appropriate syscalls profile for programs.
âœ… For nodes that support it, AppArmor or SELinux is enabled with appropriate profile for programs.

ğŸ“Œ ğ‘³ğ’ğ’ˆğ’” ğ’‚ğ’ğ’… ğ’‚ğ’–ğ’…ğ’Šğ’•ğ’Šğ’ğ’ˆ 
âœ… Audit logs, if enabled, are protected from general access.
âœ… The /ğ˜­ğ˜°ğ˜¨ğ˜´ API is disabled
âœ… Limit the content of /var/log (within the host or container where the API server is running) to Kubernetes API server logs only

ğŸ“Œ ğ‘ºğ’†ğ’„ğ’“ğ’†ğ’•ğ’”
âœ… ConfigMaps are not used to hold confidential data.
âœ… Encryption at rest is configured for the Secret API.
âœ… If appropriate, a mechanism to inject secrets stored in third-party storage is deployed and available.
âœ… Service account tokens are not mounted in pods that don't require them.
âœ… Bound service account token volume is in-use instead of non-expiring tokens

ğŸ“Œ ğ‘°ğ’ğ’‚ğ’ˆğ’†ğ’”
âœ… Minimize unnecessary content in container images.
âœ… Container images are configured to be run as unprivileged user.
âœ… References to container images are made by sha256 digests (rather than tags) via admission control.
âœ… Container images are regularly scanned during creation and in deployment, and known vulnerable software is patched


At certain times, we do require a hashtag#kubernetes cluster react quickly in case of any failures in the hosts nodes 
to make the system robust in terms of hashtag#availability and hashtag#reliability 
There are some parameters within hashtag#k8s control plane that can help achieve this

ğŸ‘‰ node-status-update-frequency & monitor-grace-period
âœ… ğ˜¯ğ˜°ğ˜¥ğ˜¦-ğ˜´ğ˜µğ˜¢ğ˜µğ˜¶ğ˜´-ğ˜¶ğ˜±ğ˜¥ğ˜¢ğ˜µğ˜¦-ğ˜§ğ˜³ğ˜¦ğ˜²ğ˜¶ğ˜¦ğ˜¯ğ˜¤ğ˜º ğ˜ªğ˜´ ğ˜¢ ğ˜¬ğ˜¶ğ˜£ğ˜¦ğ˜­ğ˜¦ğ˜µ ğ˜¤ğ˜°ğ˜¯ğ˜§ğ˜ªğ˜¨ğ˜¶ğ˜³ğ˜¢ğ˜µğ˜ªğ˜°ğ˜¯ ğ˜¸ğ˜©ğ˜ªğ˜­ğ˜¦ ğ˜¯ğ˜°ğ˜¥ğ˜¦-ğ˜®ğ˜°ğ˜¯ğ˜ªğ˜µğ˜°ğ˜³-ğ˜¨ğ˜³ğ˜¢ğ˜¤ğ˜¦-ğ˜±ğ˜¦ğ˜³ğ˜ªğ˜°ğ˜¥ ğ˜ªğ˜´ ğ˜¢ ğ˜¤ğ˜°ğ˜¯ğ˜µğ˜³ğ˜°ğ˜­ğ˜­ğ˜¦ğ˜³ ğ˜®ğ˜¢ğ˜¯ğ˜¢ğ˜¨ğ˜¦ğ˜³ ğ˜¤ğ˜°ğ˜¯ğ˜§ğ˜ªğ˜¨ğ˜¶ğ˜³ğ˜¢ğ˜µğ˜ªğ˜°ğ˜¯.
ğ˜Šğ˜°ğ˜®ğ˜£ğ˜ªğ˜¯ğ˜¢ğ˜µğ˜ªğ˜°ğ˜¯ ğ˜°ğ˜§ ğ˜£ğ˜°ğ˜µğ˜© ğ˜¸ğ˜°ğ˜³ğ˜¬ğ˜´ ğ˜¢ğ˜´ ğ˜¢ ğ˜³ğ˜¦ğ˜µğ˜³ğ˜º ğ˜±ğ˜¢ğ˜³ğ˜¢ğ˜®ğ˜¦ğ˜µğ˜¦ğ˜³.
node-monitor-grace-period = (N â€” 1) * node-status-update-frequency.
The default values are set in such a way that the nodeâ€™s kubelet tries 5 times before declaring a node as unhealthy.

ğŸ‘‰ pod-eviction-timeout
âœ… ğ˜¢ ğ˜¤ğ˜°ğ˜¯ğ˜µğ˜³ğ˜°ğ˜­ğ˜­ğ˜¦ğ˜³ ğ˜®ğ˜¢ğ˜¯ğ˜¢ğ˜¨ğ˜¦ğ˜³ ğ˜¤ğ˜°ğ˜¯ğ˜§ğ˜ªğ˜¨ğ˜¶ğ˜³ğ˜¢ğ˜µğ˜ªğ˜°ğ˜¯ ğ˜µğ˜©ğ˜¢ğ˜µ ğ˜¢ğ˜¤ğ˜µğ˜´ ğ˜¢ğ˜´ ğ˜¢ ğ˜¨ğ˜³ğ˜¢ğ˜¤ğ˜¦ ğ˜±ğ˜¦ğ˜³ğ˜ªğ˜°ğ˜¥ ğ˜§ğ˜°ğ˜³ ğ˜¥ğ˜¦ğ˜­ğ˜¦ğ˜µğ˜ªğ˜¯ğ˜¨ ğ˜±ğ˜°ğ˜¥ğ˜´ ğ˜§ğ˜³ğ˜°ğ˜® ğ˜¯ğ˜°ğ˜¥ğ˜¦ğ˜´. ğ˜‰ğ˜º ğ˜¥ğ˜¦ğ˜§ğ˜¢ğ˜¶ğ˜­ğ˜µ, ğ˜´ğ˜¦ğ˜µ ğ˜µğ˜° 5 ğ˜®ğ˜ªğ˜¯ğ˜´

ğŸ‘‰ node-monitor-period
âœ… ğ˜¢ ğ˜¤ğ˜°ğ˜¯ğ˜µğ˜³ğ˜°ğ˜­ğ˜­ğ˜¦ğ˜³ ğ˜®ğ˜¢ğ˜¯ğ˜¢ğ˜¨ğ˜¦ğ˜³ ğ˜¤ğ˜°ğ˜¯ğ˜§ğ˜ªğ˜¨ğ˜¶ğ˜³ğ˜¢ğ˜µğ˜ªğ˜°ğ˜¯ ğ˜µğ˜©ğ˜¢ğ˜µ ğ˜¸ğ˜¢ğ˜¬ğ˜¦ğ˜´ ğ˜¶ğ˜± ğ˜¤ğ˜°ğ˜¯ğ˜µğ˜³ğ˜°ğ˜­ğ˜­ğ˜¦ğ˜³ ğ˜®ğ˜¢ğ˜¯ğ˜¢ğ˜¨ğ˜¦ğ˜³ ğ˜µğ˜° ğ˜¤ğ˜©ğ˜¦ğ˜¤ğ˜¬ ğ˜µğ˜©ğ˜¦ ğ˜´ğ˜µğ˜¢ğ˜µğ˜¶ğ˜´ ğ˜°ğ˜§ ğ˜¯ğ˜°ğ˜¥ğ˜¦ğ˜´. ğ˜ğ˜°ğ˜³ ğ˜µğ˜©ğ˜¦ ğ˜´ğ˜ºğ˜´ğ˜µğ˜¦ğ˜® ğ˜µğ˜° ğ˜¸ğ˜°ğ˜³ğ˜¬ 
ğ˜¥ğ˜¦ğ˜µğ˜¦ğ˜³ğ˜®ğ˜ªğ˜¯ğ˜ªğ˜´ğ˜µğ˜ªğ˜¤ğ˜¢ğ˜­ğ˜­ğ˜º, ğ˜µğ˜©ğ˜ªğ˜´ ğ˜±ğ˜¢ğ˜³ğ˜¢ğ˜®ğ˜¦ğ˜µğ˜¦ğ˜³ ğ˜¯ğ˜¦ğ˜¦ğ˜¥ğ˜´ ğ˜µğ˜° ğ˜£ğ˜¦ ğ˜£ğ˜°ğ˜µğ˜© ğ˜­ğ˜¦ğ˜´ğ˜´ ğ˜µğ˜©ğ˜¢ğ˜¯ ğ˜¢ğ˜¯ğ˜¥ ğ˜®ğ˜¶ğ˜­ğ˜µğ˜ªğ˜±ğ˜­ğ˜¦ ğ˜°ğ˜§ ğ˜¯ğ˜°ğ˜¥ğ˜¦-ğ˜®ğ˜°ğ˜¯ğ˜ªğ˜µğ˜°ğ˜³-ğ˜¨ğ˜³ğ˜¢ğ˜¤ğ˜¦-ğ˜±ğ˜¦ğ˜³ğ˜ªğ˜°ğ˜¥

After a node fails, the Kubernetes system takes a total of node-monitor-grace-period + pod-eviction-timeout 
to get back to steady-state. Itâ€™s 5 minutes and 40 seconds for the default values
The above parameters can be modified to bring down this time to 36 ğ¬ğğœğ¬ ğŸ˜ƒ 

ğ’Œğ’–ğ’ƒğ’†ğ’ğ’†ğ’•â€™ğ’”: ğ’ğ’ğ’…ğ’†-ğ’”ğ’•ğ’‚ğ’•ğ’–ğ’”-ğ’–ğ’‘ğ’…ğ’‚ğ’•ğ’†-ğ’‡ğ’“ğ’†ğ’’ğ’–ğ’†ğ’ğ’„ğ’š=4ğ’” (ğ’‡ğ’“ğ’ğ’ 10ğ’”ğ’†ğ’„ğ’”)

ğ’„ğ’ğ’ğ’•ğ’“ğ’ğ’ğ’ğ’†ğ’“-ğ’ğ’‚ğ’ğ’‚ğ’ˆğ’†ğ’“: ğ’ğ’ğ’…ğ’†-ğ’ğ’ğ’ğ’Šğ’•ğ’ğ’“-ğ’‘ğ’†ğ’“ğ’Šğ’ğ’…=4ğ’” (ğ’‡ğ’“ğ’ğ’ 5ğ’”ğ’†ğ’„ğ’”)

ğ’„ğ’ğ’ğ’•ğ’“ğ’ğ’ğ’ğ’†ğ’“-ğ’ğ’‚ğ’ğ’‚ğ’ˆğ’†ğ’“: ğ’ğ’ğ’…ğ’†-ğ’ğ’ğ’ğ’Šğ’•ğ’ğ’“-ğ’ˆğ’“ğ’‚ğ’„ğ’†-ğ’‘ğ’†ğ’“ğ’Šğ’ğ’…=16ğ’” (ğ’‡ğ’“ğ’ğ’ 40ğ’”ğ’†ğ’„ğ’”)

ğ’„ğ’ğ’ğ’•ğ’“ğ’ğ’ğ’ğ’†ğ’“-ğ’ğ’‚ğ’ğ’‚ğ’ˆğ’†ğ’“: ğ’‘ğ’ğ’…-ğ’†ğ’—ğ’Šğ’„ğ’•ğ’Šğ’ğ’-ğ’•ğ’Šğ’ğ’†ğ’ğ’–ğ’•=20ğ’” (ğ’‡ğ’“ğ’ğ’ 5ğ’ğ’Šğ’ğ’”)

It is recommended to consult further on the implementation process as randomly changing the parameters can 
have a cascading effect specially on any multi-cluster production deployment !!

