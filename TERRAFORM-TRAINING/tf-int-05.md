

1. How would you use the moved block (introduced in Terraform v1.1) to safely refactor a large production module without triggering resource destruction, and what hidden pitfalls should you look out for when multiple teams share the same backend?
2. Describe a real‑world scenario where you would need multiple provider aliases for the same cloud provider in a single configuration. How do you ensure provider‑level attribute inheritance (e.g., assume‑role or impersonation chains) remains explicit and auditable across dozens of modules?
3. Explain how the terraform import command behaves when importing into a resource that already has state. What steps (and CLI sub‑commands) would you take to surgically merge or split state objects so that drift is avoided during the next plan/apply?
4. Sentinel policy as code: show how you’d prevent production VPCs from being created without Flow Logs even when developers run local terraform apply (i.e., outside Terraform Cloud/Enterprise). What alternatives exist if you can’t mandate the paid TFC/TFE features?
5. Remote state locking is often handled automatically. Walk me through how DynamoDB locking works under the hood for the S3 backend, including what happens if a lock table entry is orphaned. How would you detect and remediate orphan locks in a multi‑account pipeline?
6. Pre‑ and post‑conditions were added in Terraform 1.2. Give two production‑grade examples (one precondition, one postcondition) that have actually helped you catch misconfigurations before causing an outage, and explain why a simple count/for_each guard wasn’t sufficient.
7. Describe the workflow for partial configuration of backends (terraform init -backend-config=…) in automated CI/CD. How do you securely inject per‑environment secrets (e.g., bucket KMS keys) without leaking them into logs or the state file itself?
8. Under heavy CI parallelism, what race conditions can occur with the -refresh-only flag and how do you design your pipeline (including terraform plan exit codes) so that a concurrent refresh can’t overwrite in‑flight state changes?
9. Explain the difference between the state subscription model in Terraform Cloud run tasks vs. a traditional terraform output–based hand‑off between stages. In what situations would you choose run tasks to gate promotion, and how would you author one that checks for CVE announcements against plan resources?
10. When managing hundreds of workspaces, how do you structure and version backend overrides to support blue/green or canary deployments at the workspace level? Outline the trade‑offs between Terraform’s native workspaces, directory‑based workspaces, and a mono‑repo with terragrunt/atmos wrappers.
