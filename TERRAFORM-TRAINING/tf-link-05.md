

# Advanced Terraform Interview Q&A – Expert Real-Time Scenarios

| # | Question | Answer |
|---|----------|--------|
| 1 | How would you use the `moved` block (Terraform v1.1+) to safely refactor a large production module without triggering resource destruction? What are the pitfalls in shared backends? | Use the `moved` block inside `terraform` block to map old resource addresses to new ones. This ensures safe refactoring across modules or renaming.<br>**Pitfalls:** In shared backends, a teammate's plan without `moved` blocks can destroy and recreate resources. Avoid drift by communicating refactors and synchronizing plans. |
| 2 | Describe a scenario where multiple provider aliases are needed for the same cloud provider. How do you manage attribute inheritance (e.g., `assume_role`)? | Use aliases when working across accounts (e.g., dev/stage/prod) or regions. Example: managing Route53 in a shared account and EC2 in a project account.<br>Explicitly declare all attributes in each alias and avoid relying on inheritance. Use `provider` blocks in modules and pass in required aliases to maintain auditability. |
| 3 | What happens if you import a resource that already has state? How do you surgically merge/split state? | Terraform will error if importing to an address already managed in state.<br>Steps:<br>1. Use `terraform state mv` to move objects.<br>2. Use `terraform state rm` to clear old entries.<br>3. Then use `terraform import` for clean mapping.<br>Use `terraform show` to inspect and verify before the next `plan`. |
| 4 | How do you enforce Flow Logs for VPCs using Sentinel, even for local `terraform apply`? What are alternatives without TFC/TFE? | Sentinel can enforce policy on plan—deny VPCs without `flow_log` attached.<br>**Alternatives:** Use `opa` (Open Policy Agent) or `tfsec` + pre-commit hooks + CI gates. Write CLI scripts that scan `.tfplan` JSON for violations. |
| 5 | How does DynamoDB locking work in the S3 backend? How do you detect and fix orphaned locks? | DynamoDB stores a single record per state with a lock ID. On `terraform apply`, it creates a lock item. If apply fails or crashes, the lock remains.<br>To fix: check DynamoDB manually for the lock record.<br>Use `terraform force-unlock <LOCK_ID>` if confirmed safe.<br>Log pipelines should alert on long lock durations. |
| 6 | Give one real-world precondition and one postcondition example from production use. Why weren't `count`/`for_each` guards enough? | - **Precondition**: Ensure S3 buckets have encryption.<br>`precondition { condition = var.kms_key_id != "" message = "Missing KMS Key!" }`<br>- **Postcondition**: Validate CloudFront distribution has WAF attached.<br>`postcondition { condition = contains(self.web_acl_id, "waf") message = "WAF not attached." }`<br>`count` can only conditionally create — not validate configuration correctness. |
| 7 | How do you use partial backend configuration (`-backend-config=...`) in CI/CD and inject secrets securely? | Store non-sensitive backend config in `.tf` files. Use `terraform init -backend-config="kms_key_id=..."` in CI jobs.<br>Inject secrets as masked env vars or use a vault integration.<br>Ensure no echo or `set -x` in shell scripts. Avoid committing backend values to state via locals. |
| 8 | What race conditions can occur with `-refresh-only` under parallel CI runs, and how do you mitigate them? | `terraform apply -refresh-only` updates state; concurrent runs may overwrite each other.<br>Use plan locking (via backend) and serialize refresh-only steps.<br>Use exit codes to skip apply if only refresh changes occur. Implement retry + queueing in CI. |
| 9 | Compare TFC run tasks (state subscription model) vs. output-based handoffs. When to use run tasks for gating promotions? | Run tasks hook into post-plan lifecycle and inspect full plan context, not just outputs.<br>Use them to enforce policies (e.g., CVE scanning) before promotions.<br>Author using a JSON plan consumer; trigger against metadata like CVE database (e.g., with Trivy). |
| 10 | How do you structure backend overrides to support blue/green or canary deployments at scale? Pros/cons of native workspaces, directories, Terragrunt/Atmos? | - **Native workspaces**: Easy but limited visibility and state isolation.<br> - **Directory workspaces**: More explicit, easier to test per env.<br> - **Terragrunt/Atmos**: Adds layering, DRY config, promotion pipelines.<br>Backend configs can be versioned via wrapper tooling and `generate` blocks in Terragrunt. |
